{
	"info": {
		"_postman_id": "691cc14f-7391-41d1-bd5d-31020c286956",
		"name": "youtube-summarizer-collection",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "19068959"
	},
	"item": [
		{
			"name": "http://127.0.0.1:8000/summarize",
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Content-Type",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n  \"youtube_url\": \"https://youtu.be/OVc2iAiErog?si=NWSYiWzqILxtu4_Q\",\n  \"groq_api_key\": \"YOUR GROQ API KEY\"\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "http://127.0.0.1:8000/summarize",
					"protocol": "http",
					"host": [
						"127",
						"0",
						"0",
						"1"
					],
					"port": "8000",
					"path": [
						"summarize"
					]
				},
				"description": "**Purpose:**  \n  \nGenerates a concise summary (‚âà300 words) from a YouTube transcript or raw text.\n\n**Input:**\n\n- `transcript_text`: full transcript or article text\n    \n- `groq_api_key`: your Groq API key\n    \n\n**Output:**\n\n- `summary`: short summarized version of the content"
			},
			"response": [
				{
					"name": "http://127.0.0.1:8000/summarize",
					"originalRequest": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"youtube_url\": \"https://youtu.be/OVc2iAiErog?si=NWSYiWzqILxtu4_Q\",\n  \"groq_api_key\": \"YOUR GROQ API KEY\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "http://127.0.0.1:8000/summarize",
							"protocol": "http",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"summarize"
							]
						}
					},
					"_postman_previewlanguage": null,
					"header": null,
					"cookie": [],
					"body": "{\r\n    \"summary\": \"Here's a clear and concise summary of the content (~300 words):\\n\\nLangraph is a Python library that enables the creation of state machines using language models, allowing for the building of complex AI workflows. It's an extension of Langchain, which helps chain together language model operations. Langraph takes this a step further by introducing graph logic, enabling the creation of stateful visual flows.\\n\\nThe library consists of three main building blocks: nodes, edges, and conditional edges. Nodes are the actions that can be performed, such as running a function or making a call to an API. Edges are the connections between nodes, defining the flow of the process. Conditional edges allow for dynamic decision-making based on conditions, enabling the agent to choose between different nodes.\\n\\nFor example, a Langraph flow might look like this: start, chatbot, tool, end. However, with conditional edges, the agent can decide which node to go to based on the user's input. If the user asks a factual question, the agent might go to Wikipedia, while if they ask for a calculation, the agent might go to a math tool.\\n\\nThe library provides a clean and visual structure for building AI agents that can use tools, make decisions based on conditions, and know what to do next. This is similar to a vending machine, where selecting a snack (node) triggers the dispensing of the snack (edge), but with a condition to heat it if it's a hot snack.\\n\\nIn summary, Langraph empowers developers to create complex AI workflows by providing nodes for logic, edges for flow, and conditions for dynamic decision-making. This library gives language models a brain with logic and control, enabling the creation of sophisticated AI agents. In a future video, the creator plans to build a working chatbot using Langraph with tools like Wikipedia and a custom math function.\"\r\n}"
				}
			]
		},
		{
			"name": "http://127.0.0.1:8000/translate",
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Content-Type",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n  \"summary_text\": \"Here's a clear and concise summary of the content (~300 words):\\n\\nLangraph is a Python library that enables the creation of state machines using language models, allowing for the building of complex AI workflows. It's an extension of Langchain, which helps chain together language model operations. Langraph takes this a step further by introducing graph logic, enabling the creation of stateful visual flows.\\n\\nThe library consists of three main building blocks: nodes, edges, and conditional edges. Nodes are the actions that can be performed, such as running a function or making a call to an API. Edges are the connections between nodes, defining the flow of the process. Conditional edges allow for dynamic decision-making based on conditions, enabling the agent to choose between different nodes.\\n\\nFor example, a Langraph flow might look like this: start, chatbot, tool, end. However, with conditional edges, the agent can decide which node to go to based on the user's input. If the user asks a factual question, the agent might go to Wikipedia, while if they ask for a calculation, the agent might go to a math tool.\\n\\nThe library provides a clean and visual structure for building AI agents that can use tools, make decisions based on conditions, and know what to do next. This is similar to a vending machine, where selecting a snack (node) triggers the dispensing of the snack (edge), but with a condition to heat it if it's a hot snack.\\n\\nIn summary, Langraph empowers developers to create complex AI workflows by providing nodes for logic, edges for flow, and conditions for dynamic decision-making. This library gives language models a brain with logic and control, enabling the creation of sophisticated AI agents. In a future video, the creator plans to build a working chatbot using Langraph with tools like Wikipedia and a custom math function.\",\n  \"target_language\": \"Hindi\",\n  \"groq_api_key\": \"YOUR GROQ API KEY\"\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "http://127.0.0.1:8000/translate",
					"protocol": "http",
					"host": [
						"127",
						"0",
						"0",
						"1"
					],
					"port": "8000",
					"path": [
						"translate"
					]
				},
				"description": "**Purpose:**\n\nTranslates the generated summary into any target language.\n\n**Input:**\n\n- `summary_text`: text of the summary to translate\n    \n- `target_language`: desired language (e.g., `\"Hindi\"`, `\"Spanish\"`)\n    \n- `groq_api_key`: your Groq API key\n    \n\n**Output:**\n\n- `translated_summary`: translated version of the summary"
			},
			"response": [
				{
					"name": "http://127.0.0.1:8000/translate",
					"originalRequest": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"summary_text\": \"Here's a clear and concise summary of the content (~300 words):\\n\\nLangraph is a Python library that enables the creation of state machines using language models, allowing for the building of complex AI workflows. It's an extension of Langchain, which helps chain together language model operations. Langraph takes this a step further by introducing graph logic, enabling the creation of stateful visual flows.\\n\\nThe library consists of three main building blocks: nodes, edges, and conditional edges. Nodes are the actions that can be performed, such as running a function or making a call to an API. Edges are the connections between nodes, defining the flow of the process. Conditional edges allow for dynamic decision-making based on conditions, enabling the agent to choose between different nodes.\\n\\nFor example, a Langraph flow might look like this: start, chatbot, tool, end. However, with conditional edges, the agent can decide which node to go to based on the user's input. If the user asks a factual question, the agent might go to Wikipedia, while if they ask for a calculation, the agent might go to a math tool.\\n\\nThe library provides a clean and visual structure for building AI agents that can use tools, make decisions based on conditions, and know what to do next. This is similar to a vending machine, where selecting a snack (node) triggers the dispensing of the snack (edge), but with a condition to heat it if it's a hot snack.\\n\\nIn summary, Langraph empowers developers to create complex AI workflows by providing nodes for logic, edges for flow, and conditions for dynamic decision-making. This library gives language models a brain with logic and control, enabling the creation of sophisticated AI agents. In a future video, the creator plans to build a working chatbot using Langraph with tools like Wikipedia and a custom math function.\",\n  \"target_language\": \"Hindi\",\n  \"groq_api_key\": \"YOUR GROQ API KEY\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "http://127.0.0.1:8000/translate",
							"protocol": "http",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"translate"
							]
						}
					},
					"_postman_previewlanguage": null,
					"header": null,
					"cookie": [],
					"body": "{\r\n    \"translation\": \"Langraph ‡§è‡§ï ‡§™‡§æ‡§á‡§•‡§® ‡§≤‡§æ‡§á‡§¨‡•ç‡§∞‡•á‡§∞‡•Ä ‡§π‡•à ‡§ú‡•ã ‡§≠‡§æ‡§∑‡§æ ‡§Æ‡•â‡§°‡§≤‡•ã‡§Ç ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡§ï‡•á ‡§∏‡•ç‡§ü‡•á‡§ü ‡§Æ‡§∂‡•Ä‡§® ‡§ï‡§æ ‡§®‡§ø‡§∞‡•ç‡§Æ‡§æ‡§£ ‡§ï‡§∞‡§®‡•á ‡§ï‡•Ä ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§¶‡•á‡§§‡•Ä ‡§π‡•à, ‡§ú‡§ø‡§∏‡§∏‡•á ‡§ú‡§ü‡§ø‡§≤ AI ‡§ï‡§æ‡§∞‡•ç‡§Ø‡•ã‡§Ç ‡§ï‡§æ ‡§®‡§ø‡§∞‡•ç‡§Æ‡§æ‡§£ ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡•§ ‡§Ø‡§π Langchain ‡§ï‡§æ ‡§µ‡§ø‡§∏‡•ç‡§§‡§æ‡§∞ ‡§π‡•à, ‡§ú‡•ã ‡§≠‡§æ‡§∑‡§æ ‡§Æ‡•â‡§°‡§≤ ‡§ë‡§™‡§∞‡•á‡§∂‡§®‡•ã‡§Ç ‡§ï‡•ã ‡§∏‡§Ç‡§Ø‡•ã‡§ú‡§ø‡§§ ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡§§‡§æ ‡§π‡•à‡•§ Langraph ‡§®‡•á ‡§ó‡•ç‡§∞‡§æ‡§´‡§º ‡§≤‡•â‡§ú‡§ø‡§ï ‡§ï‡•ã ‡§™‡•á‡§∂ ‡§ï‡§ø‡§Ø‡§æ ‡§π‡•à, ‡§ú‡§ø‡§∏‡§∏‡•á ‡§∏‡•ç‡§ü‡•á‡§ü‡§´‡•Å‡§≤ ‡§µ‡§ø‡§ú‡§º‡•Å‡§Ö‡§≤ ‡§´‡•ç‡§≤‡•ã ‡§ï‡§æ ‡§®‡§ø‡§∞‡•ç‡§Æ‡§æ‡§£ ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡•§\\n\\n‡§≤‡§æ‡§á‡§¨‡•ç‡§∞‡•á‡§∞‡•Ä ‡§Æ‡•á‡§Ç ‡§§‡•Ä‡§® ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§®‡§ø‡§∞‡•ç‡§Æ‡§æ‡§£ ‡§¨‡•ç‡§≤‡•â‡§ï ‡§π‡•à‡§Ç: ‡§®‡•ã‡§°‡•ç‡§∏, ‡§è‡§ú‡•á‡§ú‡§º, ‡§î‡§∞ ‡§ï‡§Ç‡§°‡•Ä‡§∂‡§®‡§≤ ‡§è‡§ú‡•á‡§ú‡§º‡•§ ‡§®‡•ã‡§°‡•ç‡§∏ ‡§µ‡§π ‡§ï‡§æ‡§∞‡•ç‡§Ø ‡§π‡•à‡§Ç ‡§ú‡•ã ‡§ï‡§ø‡§è ‡§ú‡§æ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç, ‡§ú‡•à‡§∏‡•á ‡§ï‡§ø ‡§è‡§ï ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§ï‡•ã ‡§ö‡§≤‡§æ‡§®‡§æ ‡§Ø‡§æ ‡§è‡§ï API ‡§ï‡•ã ‡§ï‡•â‡§≤ ‡§ï‡§∞‡§®‡§æ‡•§ ‡§è‡§ú‡•á‡§ú‡§º ‡§®‡•ã‡§°‡•ç‡§∏ ‡§ï‡•á ‡§¨‡•Ä‡§ö ‡§ï‡•á ‡§ï‡§®‡•á‡§ï‡•ç‡§∂‡§® ‡§π‡•à‡§Ç, ‡§ú‡•ã ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§ï‡•á ‡§´‡•ç‡§≤‡•ã ‡§ï‡•ã ‡§™‡§∞‡§ø‡§≠‡§æ‡§∑‡§ø‡§§ ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç‡•§ ‡§ï‡§Ç‡§°‡•Ä‡§∂‡§®‡§≤ ‡§è‡§ú‡•á‡§ú‡§º ‡§ï‡§Ç‡§°‡•Ä‡§∂‡§® ‡§™‡§∞ ‡§Ü‡§ß‡§æ‡§∞‡§ø‡§§ ‡§°‡§æ‡§Ø‡§®‡§æ‡§Æ‡§ø‡§ï ‡§®‡§ø‡§∞‡•ç‡§£‡§Ø ‡§≤‡•á‡§®‡•á ‡§ï‡•Ä ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§¶‡•á‡§§‡•á ‡§π‡•à‡§Ç, ‡§ú‡§ø‡§∏‡§∏‡•á ‡§è‡§ú‡•á‡§Ç‡§ü ‡§ï‡•ã ‡§µ‡§ø‡§≠‡§ø‡§®‡•ç‡§® ‡§®‡•ã‡§°‡•ç‡§∏ ‡§ï‡§æ ‡§ö‡§Ø‡§® ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡§ú‡§¨‡•Ç‡§∞ ‡§π‡•ã‡§§‡§æ ‡§π‡•à‡•§\\n\\n‡§â‡§¶‡§æ‡§π‡§∞‡§£ ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§è‡§ï Langraph ‡§´‡•ç‡§≤‡•ã ‡§Ø‡§π ‡§π‡•ã ‡§∏‡§ï‡§§‡§æ ‡§π‡•à: ‡§∂‡•Å‡§∞‡•Ç, ‡§ö‡•à‡§ü‡§¨‡•â‡§ü, ‡§ü‡•Ç‡§≤, ‡§Ö‡§Ç‡§§‡•§ ‡§π‡§æ‡§≤‡§æ‡§Ç‡§ï‡§ø, ‡§ï‡§Ç‡§°‡•Ä‡§∂‡§®‡§≤ ‡§è‡§ú‡•á‡§ú‡§º ‡§ï‡•á ‡§∏‡§æ‡§•, ‡§è‡§ú‡•á‡§Ç‡§ü ‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ ‡§ï‡•Ä ‡§™‡•ç‡§∞‡§µ‡•É‡§§‡•ç‡§§‡§ø ‡§™‡§∞ ‡§®‡§ø‡§∞‡•ç‡§≠‡§∞ ‡§ï‡§∞‡§§‡•á ‡§π‡•Å‡§è ‡§®‡•ã‡§° ‡§ï‡§æ ‡§ö‡§Ø‡§® ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡§ú‡§¨‡•Ç‡§∞ ‡§π‡•ã ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡•§ ‡§Ø‡§¶‡§ø ‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ ‡§è‡§ï ‡§§‡§•‡•ç‡§Ø‡§æ‡§§‡•ç‡§Æ‡§ï ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§™‡•Ç‡§õ‡§§‡§æ ‡§π‡•à, ‡§§‡•ã ‡§è‡§ú‡•á‡§Ç‡§ü ‡§µ‡§ø‡§ï‡§ø‡§™‡•Ä‡§°‡§ø‡§Ø‡§æ ‡§ï‡•Ä ‡§ì‡§∞ ‡§ú‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à, ‡§ú‡§¨‡§ï‡§ø ‡§Ø‡§¶‡§ø ‡§µ‡•á ‡§è‡§ï ‡§ó‡§£‡§®‡§æ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§™‡•Ç‡§õ‡§§‡•á ‡§π‡•à‡§Ç, ‡§§‡•ã ‡§è‡§ú‡•á‡§Ç‡§ü ‡§è‡§ï ‡§ó‡§£‡§ø‡§§‡•Ä‡§Ø ‡§â‡§™‡§ï‡§∞‡§£ ‡§ï‡•Ä ‡§ì‡§∞ ‡§ú‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡•§\\n\\n‡§≤‡§æ‡§á‡§¨‡•ç‡§∞‡•á‡§∞‡•Ä ‡§è‡§ï ‡§∏‡§æ‡§´ ‡§î‡§∞ ‡§µ‡§ø‡§ú‡§º‡•Å‡§Ö‡§≤ ‡§∏‡§Ç‡§∞‡§ö‡§®‡§æ ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡§∞‡§§‡•Ä ‡§π‡•à ‡§ú‡§ø‡§∏‡§∏‡•á AI ‡§è‡§ú‡•á‡§Ç‡§ü ‡§¨‡§®‡§æ‡§Ø‡§æ ‡§ú‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à ‡§ú‡•ã ‡§ü‡•Ç‡§≤‡•ç‡§∏ ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç, ‡§ï‡§Ç‡§°‡•Ä‡§∂‡§® ‡§™‡§∞ ‡§Ü‡§ß‡§æ‡§∞‡§ø‡§§ ‡§®‡§ø‡§∞‡•ç‡§£‡§Ø ‡§≤‡•á ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç, ‡§î‡§∞ ‡§Ü‡§ó‡•á ‡§ï‡•ç‡§Ø‡§æ ‡§ï‡§∞‡§®‡§æ ‡§π‡•à, ‡§Ø‡§π ‡§ú‡§æ‡§®‡§§‡•á ‡§π‡•à‡§Ç‡•§ ‡§Ø‡§π ‡§è‡§ï ‡§µ‡•á‡§Ç‡§°‡§ø‡§Ç‡§ó ‡§Æ‡§∂‡•Ä‡§® ‡§ï‡•Ä ‡§§‡§∞‡§π ‡§π‡•à, ‡§ú‡§π‡§æ‡§Ç ‡§è‡§ï ‡§®‡§æ‡§∂‡•ç‡§§‡•á (‡§®‡•ã‡§°) ‡§ï‡•Ä ‡§∏election ‡§ï‡§∞‡§®‡•á ‡§™‡§∞ ‡§®‡§æ‡§∂‡•ç‡§§‡•á ‡§ï‡•ã ‡§®‡§ø‡§ï‡§æ‡§≤‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§è‡§ú‡•á‡§ú‡§º ‡§ü‡•ç‡§∞‡§ø‡§ó‡§∞ ‡§π‡•ã‡§§‡§æ ‡§π‡•à, ‡§≤‡•á‡§ï‡§ø‡§® ‡§è‡§ï ‡§ï‡§Ç‡§°‡•Ä‡§∂‡§® ‡§ï‡•á ‡§∏‡§æ‡§• ‡§ú‡•ã ‡§ó‡§∞‡•ç‡§Æ ‡§®‡§æ‡§∂‡•ç‡§§‡§æ ‡§π‡•à ‡§µ‡§π ‡§ó‡§∞‡•ç‡§Æ ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§è‡•§\\n\\n‡§®‡§ø‡§∑‡•ç‡§ï‡§∞‡•ç‡§∑ ‡§Æ‡•á‡§Ç, Langraph ‡§µ‡§ø‡§ï‡§æ‡§∏‡§ï‡•ã‡§Ç ‡§ï‡•ã ‡§ú‡§ü‡§ø‡§≤ AI ‡§ï‡§æ‡§∞‡•ç‡§Ø‡•ã‡§Ç ‡§ï‡§æ ‡§®‡§ø‡§∞‡•ç‡§Æ‡§æ‡§£ ‡§ï‡§∞‡§®‡•á ‡§ï‡•Ä ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§¶‡•á‡§§‡§æ ‡§π‡•à ‡§ú‡•ã ‡§≤‡•â‡§ú‡§ø‡§ï, ‡§è‡§ú‡•á‡§ú‡§º, ‡§î‡§∞ ‡§ï‡§Ç‡§°‡•Ä‡§∂‡§® ‡§ï‡•á ‡§≤‡§ø‡§è ‡§°‡§æ‡§Ø‡§®‡§æ‡§Æ‡§ø‡§ï ‡§®‡§ø‡§∞‡•ç‡§£‡§Ø ‡§≤‡•á‡§®‡•á ‡§ï‡•Ä ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§¶‡•á‡§§‡§æ ‡§π‡•à‡•§ ‡§Ø‡§π ‡§≤‡§æ‡§á‡§¨‡•ç‡§∞‡•á‡§∞‡•Ä ‡§≠‡§æ‡§∑‡§æ ‡§Æ‡•â‡§°‡§≤ ‡§ï‡•ã ‡§è‡§ï ‡§¨‡•ç‡§∞‡•á‡§® ‡§¶‡•á‡§§‡•Ä ‡§π‡•à ‡§ú‡§ø‡§∏‡§Æ‡•á‡§Ç ‡§≤‡•â‡§ú‡§ø‡§ï ‡§î‡§∞ ‡§®‡§ø‡§Ø‡§Ç‡§§‡•ç‡§∞‡§£ ‡§π‡•ã‡§§‡§æ ‡§π‡•à, ‡§ú‡§ø‡§∏‡§∏‡•á ‡§ú‡§ü‡§ø‡§≤ AI ‡§è‡§ú‡•á‡§Ç‡§ü ‡§ï‡§æ ‡§®‡§ø‡§∞‡•ç‡§Æ‡§æ‡§£ ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡•§ ‡§≠‡§µ‡§ø‡§∑‡•ç‡§Ø ‡§ï‡•á ‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã ‡§Æ‡•á‡§Ç, ‡§®‡§ø‡§∞‡•ç‡§Æ‡§æ‡§§‡§æ Langraph ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡§ï‡•á ‡§µ‡§ø‡§ï‡§ø‡§™‡•Ä‡§°‡§ø‡§Ø‡§æ ‡§î‡§∞ ‡§è‡§ï ‡§ï‡§∏‡•ç‡§ü‡§Æ ‡§ó‡§£‡§ø‡§§‡•Ä‡§Ø ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§ú‡•à‡§∏‡•á ‡§ü‡•Ç‡§≤‡•ç‡§∏ ‡§ï‡•á ‡§∏‡§æ‡§• ‡§è‡§ï ‡§ï‡§æ‡§Æ ‡§ï‡§∞‡§®‡•á ‡§µ‡§æ‡§≤‡§æ ‡§ö‡•à‡§ü‡§¨‡•â‡§ü ‡§¨‡§®‡§æ‡§®‡•á ‡§ï‡•Ä ‡§Ø‡•ã‡§ú‡§®‡§æ ‡§¨‡§®‡§æ ‡§∞‡§π‡•á ‡§π‡•à‡§Ç‡•§\"\r\n}"
				}
			]
		},
		{
			"name": "http://127.0.0.1:8000/notes",
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Content-Type",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n  \"transcript_text\": \"LangGraph is a Python library built on top of LangChain that allows developers to create stateful, graph-based AI workflows. It introduces nodes, edges, and conditional edges to define logic and control flow for LLM-based systems. Developers can build intelligent agents capable of making conditional decisions, such as choosing between different tools based on input context. LangGraph simplifies multi-step reasoning and tool orchestration, making it easier to design advanced AI systems with transparency and structure.\",\n  \"groq_api_key\": \"YOUR GROQ API KEY\"\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "http://127.0.0.1:8000/notes",
					"protocol": "http",
					"host": [
						"127",
						"0",
						"0",
						"1"
					],
					"port": "8000",
					"path": [
						"notes"
					]
				},
				"description": "**Purpose:**  \n  \nCreates detailed, structured **study notes** from the transcript or summary text.\n\n**Input:**\n\n- `transcript_text`: main content to convert into notes\n    \n- `groq_api_key`: your Groq API key\n    \n\n**Output:**\n\n- `notes`: formatted notes with key topics, takeaways, insights, and action steps"
			},
			"response": [
				{
					"name": "http://127.0.0.1:8000/notes",
					"originalRequest": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"transcript_text\": \"LangGraph is a Python library built on top of LangChain that allows developers to create stateful, graph-based AI workflows. It introduces nodes, edges, and conditional edges to define logic and control flow for LLM-based systems. Developers can build intelligent agents capable of making conditional decisions, such as choosing between different tools based on input context. LangGraph simplifies multi-step reasoning and tool orchestration, making it easier to design advanced AI systems with transparency and structure.\",\n  \"groq_api_key\": \"YOUR GROQ API KEY\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "http://127.0.0.1:8000/notes",
							"protocol": "http",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"notes"
							]
						}
					},
					"_postman_previewlanguage": null,
					"header": null,
					"cookie": [],
					"body": "{\r\n    \"notes\": \"**Study Notes: LangGraph and LangChain**\\n\\n** üîë Key Topics:**\\n\\n1. **LangGraph Overview**: A Python library built on top of LangChain for creating stateful, graph-based AI workflows.\\n2. **Key Features**: Nodes, edges, and conditional edges for defining logic and control flow in LLM-based systems.\\n3. **Advantages**: Simplifies multi-step reasoning and tool orchestration, enables transparency and structure in advanced AI systems.\\n\\n** üí° Main Takeaways:**\\n\\n1. LangGraph enables developers to create intelligent agents that can make conditional decisions.\\n2. It simplifies the process of designing complex AI systems with controlled logic and flow.\\n3. LangGraph is built on top of LangChain, providing a powerful foundation for AI workflow development.\\n\\n** üìù Detailed Insights:**\\n\\n1. **Nodes in LangGraph**: Nodes represent individual components or tasks within an AI workflow. They can be thought of as \\\"boxes\\\" that perform specific operations, such as text processing or data retrieval.\\n2. **Edges in LangGraph**: Edges connect nodes and represent the flow of data or control between them. Conditional edges allow for branching logic and decision-making based on input context.\\n3. **Conditional Edges**: Conditional edges enable intelligent agents to make decisions based on input context. This allows for more sophisticated control flow and decision-making in AI workflows.\\n4. **LM-based Systems**: LangGraph is designed for Large Model (LM) based systems, which leverage the power of language models to perform tasks such as text generation, classification, and more.\\n5. **Stateful Workflows**: LangGraph enables developers to create stateful AI workflows, where the state of the workflow is preserved across multiple steps or iterations.\\n\\n** üöÄ Actionable Steps:**\\n\\n1. **Explore LangGraph Documentation**: Familiarize yourself with the LangGraph documentation and API to learn more about its features and capabilities.\\n2. **Build a Simple AI Workflow**: Create a basic AI workflow using LangGraph to get hands-on experience with its node, edge, and conditional edge concepts.\\n3. **Integrate LangGraph with LangChain**: Learn how to integrate LangGraph with LangChain to leverage the full power of LangChain's language model capabilities in your AI workflows.\"\r\n}"
				}
			]
		},
		{
			"name": "http://127.0.0.1:8000/recommendations",
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Content-Type",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n  \"summary_text\": \"Here's a clear and concise summary of the content (~300 words):\\n\\nLangraph is a Python library that enables the creation of state machines using language models, allowing for the building of complex AI workflows. It's an extension of Langchain, which helps chain together language model operations. Langraph takes this a step further by introducing graph logic, enabling the creation of stateful visual flows.\\n\\nThe library consists of three main building blocks: nodes, edges, and conditional edges. Nodes are the actions that can be performed, such as running a function or making a call to an API. Edges are the connections between nodes, defining the flow of the process. Conditional edges allow for dynamic decision-making based on conditions, enabling the agent to choose between different nodes.\\n\\nFor example, a Langraph flow might look like this: start, chatbot, tool, end. However, with conditional edges, the agent can decide which node to go to based on the user's input. If the user asks a factual question, the agent might go to Wikipedia, while if they ask for a calculation, the agent might go to a math tool.\\n\\nThe library provides a clean and visual structure for building AI agents that can use tools, make decisions based on conditions, and know what to do next. This is similar to a vending machine, where selecting a snack (node) triggers the dispensing of the snack (edge), but with a condition to heat it if it's a hot snack.\\n\\nIn summary, Langraph empowers developers to create complex AI workflows by providing nodes for logic, edges for flow, and conditions for dynamic decision-making. This library gives language models a brain with logic and control, enabling the creation of sophisticated AI agents. In a future video, the creator plans to build a working chatbot using Langraph with tools like Wikipedia and a custom math function.\"\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "http://127.0.0.1:8000/recommendations",
					"protocol": "http",
					"host": [
						"127",
						"0",
						"0",
						"1"
					],
					"port": "8000",
					"path": [
						"recommendations"
					]
				},
				"description": "**Purpose:**  \n  \nGenerates personalized topic or content recommendations based on the provided summary text.\n\n**Input:**\n\n- `summary_text`: summarized content used to extract key themes and suggest related topics.\n    \n\n**Output:**\n\n- `recommendations`: list of suggested topics, learning areas, or related resources."
			},
			"response": [
				{
					"name": "http://127.0.0.1:8000/recommendations",
					"originalRequest": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"summary_text\": \"Here's a clear and concise summary of the content (~300 words):\\n\\nLangraph is a Python library that enables the creation of state machines using language models, allowing for the building of complex AI workflows. It's an extension of Langchain, which helps chain together language model operations. Langraph takes this a step further by introducing graph logic, enabling the creation of stateful visual flows.\\n\\nThe library consists of three main building blocks: nodes, edges, and conditional edges. Nodes are the actions that can be performed, such as running a function or making a call to an API. Edges are the connections between nodes, defining the flow of the process. Conditional edges allow for dynamic decision-making based on conditions, enabling the agent to choose between different nodes.\\n\\nFor example, a Langraph flow might look like this: start, chatbot, tool, end. However, with conditional edges, the agent can decide which node to go to based on the user's input. If the user asks a factual question, the agent might go to Wikipedia, while if they ask for a calculation, the agent might go to a math tool.\\n\\nThe library provides a clean and visual structure for building AI agents that can use tools, make decisions based on conditions, and know what to do next. This is similar to a vending machine, where selecting a snack (node) triggers the dispensing of the snack (edge), but with a condition to heat it if it's a hot snack.\\n\\nIn summary, Langraph empowers developers to create complex AI workflows by providing nodes for logic, edges for flow, and conditions for dynamic decision-making. This library gives language models a brain with logic and control, enabling the creation of sophisticated AI agents. In a future video, the creator plans to build a working chatbot using Langraph with tools like Wikipedia and a custom math function.\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "http://127.0.0.1:8000/recommendations",
							"protocol": "http",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"recommendations"
							]
						}
					},
					"_postman_previewlanguage": null,
					"header": null,
					"cookie": [],
					"body": "{\r\n    \"recommendations\": [\r\n        {\r\n            \"title\": \"LangChain vs LangGraph vs LangSmith\",\r\n            \"url\": \"https://www.youtube.com/watch?v=vJOGC8QJZJQ\"\r\n        },\r\n        {\r\n            \"title\": \"Memory for agents (conceptual video)\",\r\n            \"url\": \"https://www.youtube.com/watch?v=JTL0yp85FsE\"\r\n        },\r\n        {\r\n            \"title\": \"LangGraph Explained for Beginners\",\r\n            \"url\": \"https://www.youtube.com/watch?v=cUfLrn3TM3M\"\r\n        },\r\n        {\r\n            \"title\": \"Agentic Framework LangGraph explained in 8 minutes | Beginners Guide\",\r\n            \"url\": \"https://www.youtube.com/watch?v=1Q_MDOWaljk\"\r\n        },\r\n        {\r\n            \"title\": \"Why Langgraph Stands Out in AI Frameworks\",\r\n            \"url\": \"https://www.youtube.com/watch?v=TigHIJO-_g8\"\r\n        }\r\n    ]\r\n}"
				}
			]
		}
	]
}